diff --git a/extmod/extmod.mk b/extmod/extmod.mk
index a15b7e4a5..448ed00d8 100644
--- a/extmod/extmod.mk
+++ b/extmod/extmod.mk
@@ -365,4 +365,14 @@ ifeq ($(MICROPY_BLUETOOTH_BTSTACK),1)
 include $(TOP)/extmod/btstack/btstack.mk
 endif
 
+################################################################################
+# io expanders
+
+ifeq ($(MICROPY_PY_TCA9555),1)
+SRC_TCA9555R := \
+	$(wildcard drivers/tca9555/*.c)
+else
+SRC_TCA9555R :=
+endif
+
 endif
diff --git a/lib/pico-sdk b/lib/pico-sdk
--- a/lib/pico-sdk
+++ b/lib/pico-sdk
@@ -1 +1 @@
-Subproject commit 6a7db34ff63345a7badec79ebea3aaef1712f374
+Subproject commit 6a7db34ff63345a7badec79ebea3aaef1712f374-dirty
diff --git a/ports/rp2/CMakeLists.txt b/ports/rp2/CMakeLists.txt
index 4334a0aba..e298618dc 100644
--- a/ports/rp2/CMakeLists.txt
+++ b/ports/rp2/CMakeLists.txt
@@ -112,6 +112,7 @@ set(MICROPY_SOURCE_LIB
 set(MICROPY_SOURCE_DRIVERS
     ${MICROPY_DIR}/drivers/bus/softspi.c
     ${MICROPY_DIR}/drivers/dht/dht.c
+    ${MICROPY_DIR}/drivers/tca9555/tca9555.c
 )
 
 set(MICROPY_SOURCE_PORT
@@ -122,6 +123,7 @@ set(MICROPY_SOURCE_PORT
     machine_i2c.c
     machine_i2s.c
     machine_pin.c
+    machine_pin_tca9555.c
     machine_rtc.c
     machine_spi.c
     machine_timer.c
@@ -281,6 +283,22 @@ target_include_directories(${MICROPY_TARGET} PRIVATE
     ${MICROPY_DIR}/shared/tinyusb/
 )
 
+if (MICROPY_PY_TCA9555)
+    target_compile_definitions(${MICROPY_TARGET} PRIVATE
+        MICROPY_PY_TCA9555=1
+    )
+
+    list(APPEND MICROPY_SOURCE_DRIVERS
+        machine_pin_tca955555.c
+    )
+
+
+endif()
+
+target_include_directories(${MICROPY_TARGET} PRIVATE
+    ${MICROPY_DIR}/drivers/tca9555/
+)
+
 if (MICROPY_PY_NETWORK_CYW43)
     string(CONCAT GIT_SUBMODULES "${GIT_SUBMODULES} " lib/cyw43-driver)
     if((NOT (${ECHO_SUBMODULES})) AND NOT EXISTS ${MICROPY_DIR}/lib/cyw43-driver/src/cyw43.h)
@@ -371,6 +389,7 @@ endif()
 list(APPEND MICROPY_SOURCE_QSTR
     ${MICROPY_SOURCE_EXTMOD}
     ${MICROPY_SOURCE_USERMOD}
+    ${MICROPY_SOURCE_BOARD}
 )
 
 # Define mpy-cross flags
@@ -389,6 +408,7 @@ target_sources(${MICROPY_TARGET} PRIVATE
     ${MICROPY_SOURCE_LIB}
     ${MICROPY_SOURCE_DRIVERS}
     ${MICROPY_SOURCE_PORT}
+    ${MICROPY_SOURCE_BOARD}
 )
 
 target_link_libraries(${MICROPY_TARGET} micropy_lib_mbedtls)
@@ -496,6 +526,11 @@ target_sources(${MICROPY_TARGET} PRIVATE
     ${GEN_PINS_HDR}
 )
 
+# Temporary hack to get build finding correct CSV file
+pico_find_in_paths(GEN_PINS_BOARD_CSV PICO_BOARD_HEADER_DIRS pins.csv)
+message(WARNING "${GEN_PINS_BOARD_CSV}")
+set(GEN_PINS_CSV_ARG --board "${GEN_PINS_BOARD_CSV}")
+
 # Generate pins
 add_custom_command(
     OUTPUT ${GEN_PINS_HDR} ${GEN_PINS_SRC} ${GEN_PINS_QSTR}
diff --git a/ports/rp2/boards/make-pins.py b/ports/rp2/boards/make-pins.py
index 97c0ff638..6b7c6d20e 100755
--- a/ports/rp2/boards/make-pins.py
+++ b/ports/rp2/boards/make-pins.py
@@ -189,7 +189,7 @@ class Pins(object):
         self.cpu_pins = []  # list of NamedPin objects
         self.board_pins = []  # list of NamedPin objects
         self.ext_pins = []  # list of NamedPin objects
-        for i in range(0, 10):
+        for i in range(0, 32):
             self.ext_pins.append(NamedPin("EXT_GPIO{:d}".format(i), Pin(i, True)))
 
     def find_pin(self, pin_name):
diff --git a/ports/rp2/main.c b/ports/rp2/main.c
index ff0384b95..9890bf580 100644
--- a/ports/rp2/main.c
+++ b/ports/rp2/main.c
@@ -72,6 +72,9 @@ bi_decl(bi_program_feature_group_with_flags(BINARY_INFO_TAG_MICROPYTHON,
     BI_NAMED_GROUP_SEPARATE_COMMAS | BI_NAMED_GROUP_SORT_ALPHA));
 
 int main(int argc, char **argv) {
+    // Hook for setting up anything that needs to be super early in the bootup process
+    MICROPY_BOARD_STARTUP();
+
     #if MICROPY_HW_ENABLE_UART_REPL
     bi_decl(bi_program_feature("UART REPL"))
     setup_default_uart();
@@ -144,6 +147,10 @@ int main(int argc, char **argv) {
     }
     #endif
 
+    // Hook for setting up anything that can wait until after other hardware features are initialised
+    MICROPY_BOARD_EARLY_INIT();
+
+    bool run_main = true;
     for (;;) {
 
         // Initialise MicroPython runtime.
@@ -166,6 +173,9 @@ int main(int argc, char **argv) {
         mod_network_lwip_init();
         #endif
 
+        // Hook for setting up anything that should follow the MicroPy runtime but be prior to _boot.py
+        MICROPY_BOARD_LATE_INIT();
+
         // Execute _boot.py to set up the filesystem.
         #if MICROPY_VFS_FAT && MICROPY_HW_USB_MSC
         pyexec_frozen_module("_boot_fat.py", false);
@@ -173,25 +183,34 @@ int main(int argc, char **argv) {
         pyexec_frozen_module("_boot.py", false);
         #endif
 
-        // Execute user scripts.
-        int ret = pyexec_file_if_exists("boot.py");
-        if (ret & PYEXEC_FORCED_EXIT) {
-            goto soft_reset_exit;
-        }
-        if (pyexec_mode_kind == PYEXEC_MODE_FRIENDLY_REPL) {
-            ret = pyexec_file_if_exists("main.py");
+        if (run_main) {
+            // Execute user scripts.
+            int ret = pyexec_file_if_exists("boot.py");
             if (ret & PYEXEC_FORCED_EXIT) {
+                run_main = !(ret & PYEXEC_SKIP_USER_CODE);
                 goto soft_reset_exit;
             }
+            if (pyexec_mode_kind == PYEXEC_MODE_FRIENDLY_REPL) {
+                ret = pyexec_file_if_exists("main.py");
+                if (ret & PYEXEC_FORCED_EXIT) {
+                    run_main = !(ret & PYEXEC_SKIP_USER_CODE);
+                    goto soft_reset_exit;
+                }
+            }
         }
+        run_main = true;
 
         for (;;) {
             if (pyexec_mode_kind == PYEXEC_MODE_RAW_REPL) {
-                if (pyexec_raw_repl() != 0) {
+                int ret = pyexec_raw_repl();
+                if (ret != 0) {
+                    run_main = !(ret & PYEXEC_SKIP_USER_CODE);
                     break;
                 }
             } else {
-                if (pyexec_friendly_repl() != 0) {
+                int ret = pyexec_friendly_repl();
+                if (ret != 0) {
+                    run_main = !(ret & PYEXEC_SKIP_USER_CODE);
                     break;
                 }
             }
@@ -199,6 +218,10 @@ int main(int argc, char **argv) {
 
     soft_reset_exit:
         mp_printf(MP_PYTHON_PRINTER, "MPY: soft reboot\n");
+
+        // Hook for resetting anything immediately following a soft reboot command
+        MICROPY_BOARD_EARLY_RESET();
+
         #if MICROPY_PY_NETWORK
         mod_network_deinit();
         #endif
@@ -213,6 +236,9 @@ int main(int argc, char **argv) {
         #endif
         gc_sweep_all();
         mp_deinit();
+
+        // Hook for resetting anything after the MicroPy runtime has been deinitialised
+        MICROPY_BOARD_LATE_RESET();
     }
 
     return 0;
diff --git a/ports/rp2/mpconfigport.h b/ports/rp2/mpconfigport.h
index df4483166..62e4b7d95 100644
--- a/ports/rp2/mpconfigport.h
+++ b/ports/rp2/mpconfigport.h
@@ -288,3 +288,23 @@ extern void lwip_lock_release(void);
 #define MICROPY_PY_BLUETOOTH_ENTER uint32_t atomic_state = 0;
 #define MICROPY_PY_BLUETOOTH_EXIT (void)atomic_state;
 #endif
+
+#ifndef MICROPY_BOARD_STARTUP
+#define MICROPY_BOARD_STARTUP()
+#endif
+
+#ifndef MICROPY_BOARD_EARLY_INIT
+#define MICROPY_BOARD_EARLY_INIT()
+#endif
+
+#ifndef MICROPY_BOARD_LATE_INIT
+#define MICROPY_BOARD_LATE_INIT()
+#endif
+
+#ifndef MICROPY_BOARD_EARLY_RESET
+#define MICROPY_BOARD_EARLY_RESET()
+#endif
+
+#ifndef MICROPY_BOARD_LATE_RESET
+#define MICROPY_BOARD_LATE_RESET()
+#endif
diff --git a/shared/runtime/pyexec.c b/shared/runtime/pyexec.c
index e32150e5e..6208aa024 100644
--- a/shared/runtime/pyexec.c
+++ b/shared/runtime/pyexec.c
@@ -146,10 +146,10 @@ STATIC int parse_compile_execute(const void *source, mp_parse_input_kind_t input
         // check for SystemExit
         if (mp_obj_is_subclass_fast(MP_OBJ_FROM_PTR(((mp_obj_base_t *)nlr.ret_val)->type), MP_OBJ_FROM_PTR(&mp_type_SystemExit))) {
             // at the moment, the value of SystemExit is unused
-            ret = pyexec_system_exit;
+            ret = pyexec_system_exit;// | PYEXEC_FORCED_EXIT | PYEXEC_SKIP_USER_CODE;
         } else {
             mp_obj_print_exception(&mp_plat_print, MP_OBJ_FROM_PTR(nlr.ret_val));
-            ret = 0;
+            ret = 0;// | PYEXEC_FORCED_EXIT | PYEXEC_SKIP_USER_CODE;
         }
     }
 
diff --git a/shared/runtime/pyexec.h b/shared/runtime/pyexec.h
index 64c5ef943..6a2cd8b8f 100644
--- a/shared/runtime/pyexec.h
+++ b/shared/runtime/pyexec.h
@@ -41,6 +41,7 @@ extern pyexec_mode_kind_t pyexec_mode_kind;
 extern int pyexec_system_exit;
 
 #define PYEXEC_FORCED_EXIT (0x100)
+#define PYEXEC_SKIP_USER_CODE (0x200)
 
 int pyexec_raw_repl(void);
 int pyexec_friendly_repl(void);
diff --git a/drivers/tca9555/tca9555.c b/drivers/tca9555/tca9555.c
new file mode 100644
index 000000000..a9ae8b1cb
--- /dev/null
+++ b/drivers/tca9555/tca9555.c
@@ -0,0 +1,722 @@
+/*
+ * This file is part of the MicroPython project, http://micropython.org/
+ *
+ * The MIT License (MIT)
+ *
+ * Copyright (c) 2016-2022 Damien P. George
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include "py/runtime.h"
+#include "py/mphal.h"
+#include "tca9555.h"
+#include "hardware/i2c.h"
+
+#if defined(MICROPY_PY_TCA9555) && defined(MICROPY_HW_PIN_EXT_COUNT)
+/*
+static void get_pin_name(const mcu_pin_obj_t *self, qstr *package, qstr *module, qstr *name) {
+    const mp_map_t *board_map = &board_module_globals.map;
+    for (uint8_t i = 0; i < board_map->alloc; i++) {
+        if (board_map->table[i].value == MP_OBJ_FROM_PTR(self)) {
+            *package = 0;
+            *module = MP_QSTR_board;
+            *name = MP_OBJ_QSTR_VALUE(board_map->table[i].key);
+            return;
+        }
+    }
+    const mp_map_t *tca_map = &tca_module_globals.map;
+    for (uint8_t i = 0; i < tca_map->alloc; i++) {
+        if (tca_map->table[i].value == MP_OBJ_FROM_PTR(self)) {
+            *package = 0;
+            *module = MP_QSTR_tca;
+            *name = MP_OBJ_QSTR_VALUE(tca_map->table[i].key);
+            return;
+        }
+    }
+}
+
+void shared_bindings_tca9555r_pin_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
+    mcu_pin_obj_t *self = MP_OBJ_TO_PTR(self_in);
+    qstr package = MP_QSTR_Pin;
+    qstr module = MP_QSTR_pin;
+    qstr name = MP_QSTR_Pin;
+
+    get_pin_name(self, &package, &module, &name);
+    if (package) {
+        mp_printf(print, "%q.%q.%q", package, module, name);
+    } else {
+        mp_printf(print, "%q.%q", module, name);
+    }
+}
+
+//| class TcaPin:
+//|     """A class that represents a GPIO pin attached to a TCA9555R IO expander chip.
+//|
+//|     Cannot be constructed at runtime, but may be the type of a pin object
+//|     in :py:mod:`board`. A `TcaPin` can be used as a DigitalInOut, but not with other
+//|     peripherals such as `PWMOut`."""
+//|
+const mp_obj_type_t tca_pin_type = {
+    { &mp_type_type },
+    .flags = MP_TYPE_FLAG_EXTENDED,
+    .name = MP_QSTR_TcaPin,
+    .print = shared_bindings_tca9555r_pin_print,
+    MP_TYPE_EXTENDED_FIELDS(
+        .unary_op = mp_generic_unary_op,
+        )
+};
+
+const mcu_pin_obj_t *validate_obj_is_pin_including_tca(mp_obj_t obj, qstr arg_name) {
+    if (!mp_obj_is_type(obj, &mcu_pin_type) && !mp_obj_is_type(obj, &tca_pin_type)) {
+        mp_raise_TypeError_varg(translate("%q must be of type %q or %q, not %q"), arg_name, mcu_pin_type.name, tca_pin_type.name, mp_obj_get_type(obj)->name);
+    }
+    return MP_OBJ_TO_PTR(obj);
+}
+
+const mcu_pin_obj_t *validate_obj_is_free_pin_including_tca(mp_obj_t obj, qstr arg_name) {
+    const mcu_pin_obj_t *pin = validate_obj_is_pin_including_tca(obj, arg_name);
+    assert_pin_free(pin);
+    return pin;
+}
+
+// Validate that the obj is a free pin or None. Return an mcu_pin_obj_t* or NULL, correspondingly.
+const mcu_pin_obj_t *validate_obj_is_free_pin_including_tca_or_none(mp_obj_t obj, qstr arg_name) {
+    if (obj == mp_const_none) {
+        return NULL;
+    }
+    return validate_obj_is_free_pin_including_tca(obj, arg_name);
+}
+*/
+static const uint8_t tca9555r_addresses[TCA9555R_CHIP_COUNT] = TCA9555R_CHIP_ADDRESSES;
+#if TCA9555R_LOCAL_MEMORY
+uint8_t tca9555r_output_state[TCA9555R_CHIP_COUNT * 2] = {0};
+uint8_t tca9555r_config_state[TCA9555R_CHIP_COUNT * 2] = {0};
+uint8_t tca9555r_polarity_state[TCA9555R_CHIP_COUNT * 2] = {0};
+#endif
+bool i2c_created = false;
+
+void configure_i2c() {
+    if(!i2c_created) {
+        i2c_init(i2c0, 400000);
+        i2c_set_baudrate(i2c0, 400000);
+        gpio_set_function(MICROPY_HW_I2C0_SCL, GPIO_FUNC_I2C);
+        gpio_set_function(MICROPY_HW_I2C0_SDA, GPIO_FUNC_I2C);
+        gpio_set_pulls(MICROPY_HW_I2C0_SCL, true, 0);
+        gpio_set_pulls(MICROPY_HW_I2C0_SDA, true, 0);
+        i2c_created = true;
+    }
+}
+
+#define BUS_TIMEOUT_US 1000000
+
+static void reg_write_uint8(uint8_t address, uint8_t reg, uint8_t value) {
+    uint8_t buffer[2] = {reg, value};
+    i2c_write_timeout_us(i2c0, address, buffer, 2, false, BUS_TIMEOUT_US);
+}
+
+static void reg_write_uint16(uint8_t address, uint8_t reg, uint16_t value) {
+    uint8_t buffer[3] = { reg, (uint8_t)(value & 0xFF), (uint8_t)(value >> 8) };
+    i2c_write_timeout_us(i2c0, address, buffer, 3, false, BUS_TIMEOUT_US);
+}
+
+static uint8_t reg_read_uint8(uint8_t address, uint8_t reg) {
+    uint8_t value;
+    i2c_write_timeout_us(i2c0, address, &reg, 1, false, BUS_TIMEOUT_US);
+    i2c_read_timeout_us(i2c0, address, (uint8_t *)&value, sizeof(uint8_t), false, BUS_TIMEOUT_US);
+    return value;
+}
+
+static uint16_t reg_read_uint16(uint8_t address, uint8_t reg) {
+    uint16_t value;
+    i2c_write_timeout_us(i2c0, address, &reg, 1, true, BUS_TIMEOUT_US);
+    i2c_read_timeout_us(i2c0, address, (uint8_t *)&value, sizeof(uint16_t), false, BUS_TIMEOUT_US);
+    return value;
+}
+
+bool tca_gpio_get_input(uint tca_gpio) {
+    invalid_params_if(TCA9555R, tca_gpio >= TCA9555R_VIRTUAL_GPIO_COUNT);
+    configure_i2c();
+    uint8_t address = ADDRESS_FROM_GPIO(tca_gpio);
+
+    uint8_t reg = IS_PORT1(tca_gpio) ? INPUT_PORT1 : INPUT_PORT0;
+    uint8_t input_state = reg_read_uint8(address, reg);
+    return (input_state & GPIO_BIT_MASK(tca_gpio)) != 0;
+}
+
+bool tca_gpio_get_output(uint tca_gpio) {
+    invalid_params_if(TCA9555R, tca_gpio >= TCA9555R_VIRTUAL_GPIO_COUNT);
+    configure_i2c();
+    uint8_t address = ADDRESS_FROM_GPIO(tca_gpio);
+
+    uint8_t reg = IS_PORT1(tca_gpio) ? OUTPUT_PORT1 : OUTPUT_PORT0;
+    uint8_t output_state = reg_read_uint8(address, reg);
+    #if TCA9555R_LOCAL_MEMORY
+    tca9555r_output_state[GPIO_BYTE(tca_gpio)] = output_state;
+    #endif
+    return (output_state & GPIO_BIT_MASK(tca_gpio)) != 0;
+}
+
+bool tca_gpio_get_config(uint tca_gpio) {
+    invalid_params_if(TCA9555R, tca_gpio >= TCA9555R_VIRTUAL_GPIO_COUNT);
+    configure_i2c();
+    uint8_t address = ADDRESS_FROM_GPIO(tca_gpio);
+
+    uint8_t reg = IS_PORT1(tca_gpio) ? CONFIGURATION_PORT1 : CONFIGURATION_PORT0;
+    uint8_t config_state = reg_read_uint8(address, reg);
+    #if TCA9555R_LOCAL_MEMORY
+    tca9555r_config_state[GPIO_BYTE(tca_gpio)] = config_state;
+    #endif
+    return (config_state & GPIO_BIT_MASK(tca_gpio)) == 0;
+}
+
+bool tca_gpio_get_polarity(uint tca_gpio) {
+    invalid_params_if(TCA9555R, tca_gpio >= TCA9555R_VIRTUAL_GPIO_COUNT);
+    configure_i2c();
+    uint8_t address = ADDRESS_FROM_GPIO(tca_gpio);
+
+    uint8_t reg = IS_PORT1(tca_gpio) ? POLARITY_PORT1 : POLARITY_PORT0;
+    uint8_t polarity_state = reg_read_uint8(address, reg);
+    #if TCA9555R_LOCAL_MEMORY
+    tca9555r_polarity_state[GPIO_BYTE(tca_gpio)] = polarity_state;
+    #endif
+    return (polarity_state & GPIO_BIT_MASK(tca_gpio)) != 0;
+}
+
+void tca_gpio_set_output(uint tca_gpio, bool value) {
+    invalid_params_if(TCA9555R, tca_gpio >= TCA9555R_VIRTUAL_GPIO_COUNT);
+    configure_i2c();
+    uint8_t address = ADDRESS_FROM_GPIO(tca_gpio);
+
+    uint8_t reg = IS_PORT1(tca_gpio) ? OUTPUT_PORT1 : OUTPUT_PORT0;
+    #if TCA9555R_LOCAL_MEMORY
+    uint8_t output_state = tca9555r_output_state[GPIO_BYTE(tca_gpio)];
+    #else
+    uint8_t output_state = reg_read_uint8(address, reg);
+    #endif
+    uint8_t new_output_state;
+    if (value) {
+        new_output_state = output_state | GPIO_BIT_MASK(tca_gpio);
+    } else {
+        new_output_state = output_state & ~GPIO_BIT_MASK(tca_gpio);
+    }
+
+    if (new_output_state != output_state) {
+        reg_write_uint8(address, reg, new_output_state);
+        #if TCA9555R_LOCAL_MEMORY
+        tca9555r_output_state[GPIO_BYTE(tca_gpio)] = new_output_state;
+        #endif
+    }
+}
+
+void tca_gpio_set_config(uint tca_gpio, bool output) {
+    invalid_params_if(TCA9555R, tca_gpio >= TCA9555R_VIRTUAL_GPIO_COUNT);
+    configure_i2c();
+    uint8_t address = ADDRESS_FROM_GPIO(tca_gpio);
+
+    uint8_t reg = IS_PORT1(tca_gpio) ? CONFIGURATION_PORT1 : CONFIGURATION_PORT0;
+    #if TCA9555R_LOCAL_MEMORY
+    uint8_t config_state = tca9555r_config_state[GPIO_BYTE(tca_gpio)];
+    #else
+    uint8_t config_state = reg_read_uint8(address, reg);
+    #endif
+    uint8_t new_config_state;
+    if (output) {
+        new_config_state = config_state & ~GPIO_BIT_MASK(tca_gpio);
+    } else {
+        new_config_state = config_state | GPIO_BIT_MASK(tca_gpio);
+    }
+
+    if (new_config_state != config_state) {
+        reg_write_uint8(address, reg, new_config_state);
+        #if TCA9555R_LOCAL_MEMORY
+        tca9555r_config_state[GPIO_BYTE(tca_gpio)] = new_config_state;
+        #endif
+    }
+}
+
+void tca_gpio_set_polarity(uint tca_gpio, bool polarity) {
+    invalid_params_if(TCA9555R, tca_gpio >= TCA9555R_VIRTUAL_GPIO_COUNT);
+    configure_i2c();
+    uint8_t address = ADDRESS_FROM_GPIO(tca_gpio);
+
+    uint8_t reg = IS_PORT1(tca_gpio) ? POLARITY_PORT1 : POLARITY_PORT0;
+    #if TCA9555R_LOCAL_MEMORY
+    uint8_t polarity_state = tca9555r_polarity_state[GPIO_BYTE(tca_gpio)];
+    #else
+    uint8_t polarity_state = reg_read_uint8(address, reg);
+    #endif
+    uint8_t new_polarity_state;
+    if (polarity) {
+        new_polarity_state = polarity_state | GPIO_BIT_MASK(tca_gpio);
+    } else {
+        new_polarity_state = polarity_state & ~GPIO_BIT_MASK(tca_gpio);
+    }
+
+    if (new_polarity_state != polarity_state) {
+        reg_write_uint8(address, reg, new_polarity_state);
+        #if TCA9555R_LOCAL_MEMORY
+        tca9555r_output_state[GPIO_BYTE(tca_gpio)] = new_polarity_state;
+        #endif
+    }
+}
+
+uint16_t tca_get_input_port(uint tca_index) {
+    invalid_params_if(TCA9555R, tca_index >= TCA9555R_CHIP_COUNT);
+    configure_i2c();
+    return reg_read_uint16(tca9555r_addresses[tca_index], INPUT_PORT0);
+}
+
+uint8_t tca_get_input_port_low(uint tca_index) {
+    invalid_params_if(TCA9555R, tca_index >= TCA9555R_CHIP_COUNT);
+    configure_i2c();
+    return reg_read_uint8(tca9555r_addresses[tca_index], INPUT_PORT0);
+}
+
+uint8_t tca_get_input_port_high(uint tca_index) {
+    invalid_params_if(TCA9555R, tca_index >= TCA9555R_CHIP_COUNT);
+    configure_i2c();
+    return reg_read_uint8(tca9555r_addresses[tca_index], INPUT_PORT1);
+}
+
+uint16_t tca_get_output_port(uint tca_index) {
+    invalid_params_if(TCA9555R, tca_index >= TCA9555R_CHIP_COUNT);
+    configure_i2c();
+    uint16_t output_state = reg_read_uint16(tca9555r_addresses[tca_index], OUTPUT_PORT0);
+    #if TCA9555R_LOCAL_MEMORY
+    tca9555r_output_state[HIGH_BYTE(tca_index)] = (output_state >> 8);
+    tca9555r_output_state[LOW_BYTE(tca_index)] = (output_state & 0xFF);
+    #endif
+    return output_state;
+}
+
+uint8_t tca_get_output_port_low(uint tca_index) {
+    invalid_params_if(TCA9555R, tca_index >= TCA9555R_CHIP_COUNT);
+    configure_i2c();
+    uint8_t output_state = reg_read_uint8(tca9555r_addresses[tca_index], OUTPUT_PORT0);
+    #if TCA9555R_LOCAL_MEMORY
+    tca9555r_output_state[LOW_BYTE(tca_index)] = output_state;
+    #endif
+    return output_state;
+}
+
+uint8_t tca_get_output_port_high(uint tca_index) {
+    invalid_params_if(TCA9555R, tca_index >= TCA9555R_CHIP_COUNT);
+    configure_i2c();
+    uint8_t output_state = reg_read_uint8(tca9555r_addresses[tca_index], OUTPUT_PORT1);
+    #if TCA9555R_LOCAL_MEMORY
+    tca9555r_output_state[HIGH_BYTE(tca_index)] = output_state;
+    #endif
+    return output_state;
+}
+
+uint16_t tca_get_config_port(uint tca_index) {
+    invalid_params_if(TCA9555R, tca_index >= TCA9555R_CHIP_COUNT);
+    configure_i2c();
+    uint16_t config_state = reg_read_uint16(tca9555r_addresses[tca_index], CONFIGURATION_PORT0);
+    #if TCA9555R_LOCAL_MEMORY
+    tca9555r_config_state[HIGH_BYTE(tca_index)] = (config_state >> 8);
+    tca9555r_config_state[LOW_BYTE(tca_index)] = (config_state & 0xFF);
+    #endif
+    return config_state;
+}
+
+uint8_t tca_get_config_port_low(uint tca_index) {
+    invalid_params_if(TCA9555R, tca_index >= TCA9555R_CHIP_COUNT);
+    configure_i2c();
+    uint8_t config_state = reg_read_uint8(tca9555r_addresses[tca_index], CONFIGURATION_PORT0);
+    #if TCA9555R_LOCAL_MEMORY
+    tca9555r_config_state[LOW_BYTE(tca_index)] = config_state;
+    #endif
+    return config_state;
+}
+
+uint8_t tca_get_config_port_high(uint tca_index) {
+    invalid_params_if(TCA9555R, tca_index >= TCA9555R_CHIP_COUNT);
+    configure_i2c();
+    uint8_t config_state = reg_read_uint8(tca9555r_addresses[tca_index], CONFIGURATION_PORT1);
+    #if TCA9555R_LOCAL_MEMORY
+    tca9555r_config_state[HIGH_BYTE(tca_index)] = config_state;
+    #endif
+    return config_state;
+}
+
+uint16_t tca_get_polarity_port(uint tca_index) {
+    invalid_params_if(TCA9555R, tca_index >= TCA9555R_CHIP_COUNT);
+    configure_i2c();
+    uint16_t polarity_state = reg_read_uint16(tca9555r_addresses[tca_index], POLARITY_PORT0);
+    #if TCA9555R_LOCAL_MEMORY
+    tca9555r_polarity_state[HIGH_BYTE(tca_index)] = (polarity_state >> 8);
+    tca9555r_polarity_state[LOW_BYTE(tca_index)] = (polarity_state & 0xFF);
+    #endif
+    return polarity_state;
+}
+
+uint8_t tca_get_polarity_port_low(uint tca_index) {
+    invalid_params_if(TCA9555R, tca_index >= TCA9555R_CHIP_COUNT);
+    configure_i2c();
+    uint8_t polarity_state = reg_read_uint8(tca9555r_addresses[tca_index], POLARITY_PORT0);
+    #if TCA9555R_LOCAL_MEMORY
+    tca9555r_polarity_state[LOW_BYTE(tca_index)] = polarity_state;
+    #endif
+    return polarity_state;
+}
+
+uint8_t tca_get_polarity_port_high(uint tca_index) {
+    invalid_params_if(TCA9555R, tca_index >= TCA9555R_CHIP_COUNT);
+    configure_i2c();
+    uint8_t polarity_state = reg_read_uint8(tca9555r_addresses[tca_index], POLARITY_PORT1);
+    #if TCA9555R_LOCAL_MEMORY
+    tca9555r_polarity_state[HIGH_BYTE(tca_index)] = polarity_state;
+    #endif
+    return polarity_state;
+}
+
+void tca_set_output_port(uint tca_index, uint16_t output_state) {
+    invalid_params_if(TCA9555R, tca_index >= TCA9555R_CHIP_COUNT);
+    configure_i2c();
+    reg_write_uint16(tca9555r_addresses[tca_index], OUTPUT_PORT0, output_state);
+    #if TCA9555R_LOCAL_MEMORY
+    tca9555r_output_state[HIGH_BYTE(tca_index)] = (output_state >> 8);
+    tca9555r_output_state[LOW_BYTE(tca_index)] = (output_state & 0xFF);
+    #endif
+}
+
+void tca_set_output_port_low(uint tca_index, uint8_t output_state) {
+    invalid_params_if(TCA9555R, tca_index >= TCA9555R_CHIP_COUNT);
+    configure_i2c();
+    reg_write_uint8(tca9555r_addresses[tca_index], OUTPUT_PORT0, output_state);
+    #if TCA9555R_LOCAL_MEMORY
+    tca9555r_output_state[LOW_BYTE(tca_index)] = output_state;
+    #endif
+}
+
+void tca_set_output_port_high(uint tca_index, uint8_t output_state) {
+    invalid_params_if(TCA9555R, tca_index >= TCA9555R_CHIP_COUNT);
+    configure_i2c();
+    reg_write_uint8(tca9555r_addresses[tca_index], OUTPUT_PORT1, output_state);
+    #if TCA9555R_LOCAL_MEMORY
+    tca9555r_output_state[HIGH_BYTE(tca_index)] = output_state;
+    #endif
+}
+
+void tca_set_config_port(uint tca_index, uint16_t config_state) {
+    invalid_params_if(TCA9555R, tca_index >= TCA9555R_CHIP_COUNT);
+    configure_i2c();
+    reg_write_uint16(tca9555r_addresses[tca_index], CONFIGURATION_PORT0, config_state);
+    #if TCA9555R_LOCAL_MEMORY
+    tca9555r_config_state[HIGH_BYTE(tca_index)] = (config_state >> 8);
+    tca9555r_config_state[LOW_BYTE(tca_index)] = (config_state & 0xFF);
+    #endif
+}
+
+void tca_set_config_port_low(uint tca_index, uint8_t config_state) {
+    invalid_params_if(TCA9555R, tca_index >= TCA9555R_CHIP_COUNT);
+    configure_i2c();
+    reg_write_uint8(tca9555r_addresses[tca_index], CONFIGURATION_PORT0, config_state);
+    #if TCA9555R_LOCAL_MEMORY
+    tca9555r_config_state[LOW_BYTE(tca_index)] = config_state;
+    #endif
+}
+
+void tca_set_config_port_high(uint tca_index, uint8_t config_state) {
+    invalid_params_if(TCA9555R, tca_index >= TCA9555R_CHIP_COUNT);
+    configure_i2c();
+    reg_write_uint8(tca9555r_addresses[tca_index], CONFIGURATION_PORT1, config_state);
+    #if TCA9555R_LOCAL_MEMORY
+    tca9555r_config_state[HIGH_BYTE(tca_index)] = config_state;
+    #endif
+}
+
+void tca_set_polarity_port(uint tca_index, uint16_t polarity_state) {
+    invalid_params_if(TCA9555R, tca_index >= TCA9555R_CHIP_COUNT);
+    configure_i2c();
+    reg_write_uint16(tca9555r_addresses[tca_index], POLARITY_PORT0, polarity_state);
+    #if TCA9555R_LOCAL_MEMORY
+    tca9555r_polarity_state[HIGH_BYTE(tca_index)] = (polarity_state >> 8);
+    tca9555r_polarity_state[LOW_BYTE(tca_index)] = (polarity_state & 0xFF);
+    #endif
+}
+
+void tca_set_polarity_port_low(uint tca_index, uint8_t polarity_state) {
+    invalid_params_if(TCA9555R, tca_index >= TCA9555R_CHIP_COUNT);
+    configure_i2c();
+    reg_write_uint8(tca9555r_addresses[tca_index], POLARITY_PORT0, polarity_state);
+    #if TCA9555R_LOCAL_MEMORY
+    tca9555r_polarity_state[LOW_BYTE(tca_index)] = polarity_state;
+    #endif
+}
+
+void tca_set_polarity_port_high(uint tca_index, uint8_t polarity_state) {
+    invalid_params_if(TCA9555R, tca_index >= TCA9555R_CHIP_COUNT);
+    configure_i2c();
+    reg_write_uint8(tca9555r_addresses[tca_index], POLARITY_PORT1, polarity_state);
+    #if TCA9555R_LOCAL_MEMORY
+    tca9555r_polarity_state[HIGH_BYTE(tca_index)] = polarity_state;
+    #endif
+}
+
+void tca_change_output_mask(uint8_t chip, uint16_t mask, uint16_t state) {
+    uint8_t low_mask = (uint8_t)(mask & 0xFF);
+    uint8_t low_state = (uint8_t)(state & 0xFF);
+    uint8_t high_mask = (uint8_t)(mask >> 8);
+    uint8_t high_state = (uint8_t)(state >> 8);
+    bool low_changed = low_mask > 0;
+    bool high_changed = high_mask > 0;
+    if (low_changed && high_changed) {
+        #if TCA9555R_LOCAL_MEMORY
+        uint16_t output_state = (tca9555r_output_state[HIGH_BYTE(chip)] << 8) | tca9555r_output_state[LOW_BYTE(chip)];
+        #else
+        uint16_t output_state = tca_get_output_port(chip);
+        #endif
+        uint16_t new_output_state = output_state;
+        new_output_state &= ~mask; // Clear the mask bits
+        new_output_state |= state; // Set the state bits
+        if (new_output_state != output_state) {
+            tca_set_output_port(chip, new_output_state);
+        }
+    } else if (low_changed) {
+        #if TCA9555R_LOCAL_MEMORY
+        uint8_t output_state = tca9555r_output_state[LOW_BYTE(chip)];
+        #else
+        uint8_t output_state = tca_get_output_port_low(chip);
+        #endif
+        uint8_t new_output_state = (output_state & ~low_mask) | low_state;
+        if (new_output_state != output_state) {
+            tca_set_output_port_low(chip, new_output_state);
+        }
+    } else if (high_changed) {
+        #if TCA9555R_LOCAL_MEMORY
+        uint8_t output_state = tca9555r_output_state[HIGH_BYTE(chip)];
+        #else
+        uint8_t output_state = tca_get_output_port_high(chip);
+        #endif
+        uint8_t new_output_state = (output_state & ~high_mask) | high_state;
+        if (new_output_state != output_state) {
+            tca_set_output_port_high(chip, new_output_state);
+        }
+    }
+}
+/*
+STATIC mp_obj_t tca_pin_get_number(mp_obj_t pin_obj) {
+    if (!mp_obj_is_type(pin_obj, &tca_pin_type)) {
+        mp_raise_TypeError_varg(translate("%q must be of type %q, not %q"), MP_QSTR_pin, tca_pin_type.name, mp_obj_get_type(pin_obj)->name);
+    }
+
+    mcu_pin_obj_t *pin = MP_OBJ_TO_PTR(pin_obj);
+    uint8_t tca_gpio = pin->number;
+    invalid_params_if(TCA9555R, tca_gpio >= TCA9555R_VIRTUAL_GPIO_COUNT);
+
+    return mp_obj_new_int(tca_gpio % TCA9555R_GPIO_COUNT);
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(tca_pin_get_number_obj, tca_pin_get_number);
+
+STATIC mp_obj_t tca_pin_get_chip(mp_obj_t pin_obj) {
+    if (!mp_obj_is_type(pin_obj, &tca_pin_type)) {
+        mp_raise_TypeError_varg(translate("%q must be of type %q, not %q"), MP_QSTR_pin, tca_pin_type.name, mp_obj_get_type(pin_obj)->name);
+    }
+
+    mcu_pin_obj_t *pin = MP_OBJ_TO_PTR(pin_obj);
+    uint8_t tca_gpio = pin->number;
+    invalid_params_if(TCA9555R, tca_gpio >= TCA9555R_VIRTUAL_GPIO_COUNT);
+
+    return mp_obj_new_int(CHIP_FROM_GPIO(tca_gpio));
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(tca_pin_get_chip_obj, tca_pin_get_chip);
+
+
+
+STATIC mp_obj_t tca_pin_change_output_mask(mp_obj_t chip_obj, mp_obj_t mask_obj, mp_obj_t state_obj) {
+    int chip = mp_obj_get_int(chip_obj);
+    int mask = mp_obj_get_int(mask_obj);
+    int state = mp_obj_get_int(state_obj);
+    if (chip < 0 || chip >= TCA9555R_CHIP_COUNT) {
+        mp_raise_TypeError_varg(translate("chip can only be 0 to %q"), TCA9555R_CHIP_COUNT - 1);
+    }
+    if (mask < 0 || mask > UINT16_MAX) {
+        mp_raise_TypeError(translate("mask only supports 16 bits"));
+    }
+    if (state < 0 || state > UINT16_MAX) {
+        mp_raise_TypeError(translate("state only supports 16 bits"));
+    }
+
+    tca_change_output_mask(chip, mask, state);
+
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_3(tca_pin_change_output_mask_obj, tca_pin_change_output_mask);
+*/
+#if TCA9555R_READ_INTERNALS
+STATIC mp_obj_t tca_port_read_input_state(mp_obj_t chip_obj) {
+    int chip = mp_obj_get_int(chip_obj);
+    if (chip < 0 || chip >= TCA9555R_CHIP_COUNT) {
+        mp_raise_TypeError_varg(translate("chip can only be 0 to %q"), TCA9555R_CHIP_COUNT - 1);
+    }
+
+    return mp_obj_new_int(tca_get_input_port(chip));
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(tca_port_read_input_state_obj, tca_port_read_input_state);
+
+STATIC mp_obj_t tca_port_read_output_state(mp_obj_t chip_obj) {
+    int chip = mp_obj_get_int(chip_obj);
+    if (chip < 0 || chip >= TCA9555R_CHIP_COUNT) {
+        mp_raise_TypeError_varg(translate("chip can only be 0 to %q"), TCA9555R_CHIP_COUNT - 1);
+    }
+
+    return mp_obj_new_int(tca_get_output_port(chip));
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(tca_port_read_output_state_obj, tca_port_read_output_state);
+
+STATIC mp_obj_t tca_port_read_config_state(mp_obj_t chip_obj) {
+    int chip = mp_obj_get_int(chip_obj);
+    if (chip < 0 || chip >= TCA9555R_CHIP_COUNT) {
+        mp_raise_TypeError_varg(translate("chip can only be 0 to %q"), TCA9555R_CHIP_COUNT - 1);
+    }
+
+    return mp_obj_new_int(tca_get_config_port(chip));
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(tca_port_read_config_state_obj, tca_port_read_config_state);
+
+STATIC mp_obj_t tca_port_read_polarity_state(mp_obj_t chip_obj) {
+    int chip = mp_obj_get_int(chip_obj);
+    if (chip < 0 || chip >= TCA9555R_CHIP_COUNT) {
+        mp_raise_TypeError_varg(translate("chip can only be 0 to %q"), TCA9555R_CHIP_COUNT - 1);
+    }
+
+    return mp_obj_new_int(tca_get_polarity_port(chip));
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(tca_port_read_polarity_state_obj, tca_port_read_polarity_state);
+
+#if TCA9555R_LOCAL_MEMORY
+STATIC mp_obj_t tca_port_stored_output_state(mp_obj_t chip_obj) {
+    int chip = mp_obj_get_int(chip_obj);
+    if (chip < 0 || chip >= TCA9555R_CHIP_COUNT) {
+        mp_raise_TypeError_varg(translate("chip can only be 0 to %q"), TCA9555R_CHIP_COUNT - 1);
+    }
+
+    return mp_obj_new_int((tca9555r_output_state[HIGH_BYTE(chip)] << 8) | tca9555r_output_state[LOW_BYTE(chip)]);
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(tca_port_stored_output_state_obj, tca_port_stored_output_state);
+
+STATIC mp_obj_t tca_port_stored_config_state(mp_obj_t chip_obj) {
+    int chip = mp_obj_get_int(chip_obj);
+    if (chip < 0 || chip >= TCA9555R_CHIP_COUNT) {
+        mp_raise_TypeError_varg(translate("chip can only be 0 to %q"), TCA9555R_CHIP_COUNT - 1);
+    }
+
+    return mp_obj_new_int((tca9555r_config_state[HIGH_BYTE(chip)] << 8) | tca9555r_config_state[LOW_BYTE(chip)]);
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(tca_port_stored_config_state_obj, tca_port_stored_config_state);
+
+STATIC mp_obj_t tca_port_stored_polarity_state(mp_obj_t chip_obj) {
+    int chip = mp_obj_get_int(chip_obj);
+    if (chip < 0 || chip >= TCA9555R_CHIP_COUNT) {
+        mp_raise_TypeError_varg(translate("chip can only be 0 to %q"), TCA9555R_CHIP_COUNT - 1);
+    }
+
+    return mp_obj_new_int((tca9555r_polarity_state[HIGH_BYTE(chip)] << 8) | tca9555r_polarity_state[LOW_BYTE(chip)]);
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(tca_port_stored_polarity_state_obj, tca_port_stored_polarity_state);
+#endif
+#endif
+/*
+#define TCA_PIN(exp_number, p_number) \
+    const mcu_pin_obj_t pin_TCA##exp_number##_##p_number = { \
+        { &tca_pin_type }, \
+        .number = p_number + (exp_number << 4) \
+    }
+
+#define TCA_PINS(exp_number) \
+    TCA_PIN(exp_number, 0); \
+    TCA_PIN(exp_number, 1); \
+    TCA_PIN(exp_number, 2); \
+    TCA_PIN(exp_number, 3); \
+    TCA_PIN(exp_number, 4); \
+    TCA_PIN(exp_number, 5); \
+    TCA_PIN(exp_number, 6); \
+    TCA_PIN(exp_number, 7); \
+    TCA_PIN(exp_number, 8); \
+    TCA_PIN(exp_number, 9); \
+    TCA_PIN(exp_number, 10); \
+    TCA_PIN(exp_number, 11); \
+    TCA_PIN(exp_number, 12); \
+    TCA_PIN(exp_number, 13); \
+    TCA_PIN(exp_number, 14); \
+    TCA_PIN(exp_number, 15)
+
+#if CIRCUITPY_TCA9555R
+TCA_PINS(0);
+TCA_PINS(1);
+#endif
+
+#define TCA_ENTRY(exp_number, p_number) \
+    { MP_ROM_QSTR(MP_QSTR_TCA##exp_number##_##p_number), MP_ROM_PTR(&pin_TCA##exp_number##_##p_number) }
+
+#define TCA_ENTRIES(exp_number) \
+    TCA_ENTRY(exp_number, 0), \
+    TCA_ENTRY(exp_number, 1), \
+    TCA_ENTRY(exp_number, 2), \
+    TCA_ENTRY(exp_number, 3), \
+    TCA_ENTRY(exp_number, 4), \
+    TCA_ENTRY(exp_number, 5), \
+    TCA_ENTRY(exp_number, 6), \
+    TCA_ENTRY(exp_number, 7), \
+    TCA_ENTRY(exp_number, 8), \
+    TCA_ENTRY(exp_number, 9), \
+    TCA_ENTRY(exp_number, 10), \
+    TCA_ENTRY(exp_number, 11), \
+    TCA_ENTRY(exp_number, 12), \
+    TCA_ENTRY(exp_number, 13), \
+    TCA_ENTRY(exp_number, 14), \
+    TCA_ENTRY(exp_number, 15)
+
+STATIC const mp_rom_map_elem_t tca_module_globals_table[] = {
+    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_tca) },
+    { MP_ROM_QSTR(MP_QSTR_TcaPin), MP_ROM_PTR(&tca_pin_type) },
+    { MP_ROM_QSTR(MP_QSTR_get_number), &tca_pin_get_number_obj },
+    { MP_ROM_QSTR(MP_QSTR_get_chip), &tca_pin_get_chip_obj },
+    { MP_ROM_QSTR(MP_QSTR_change_output_mask), &tca_pin_change_output_mask_obj },
+    #if TCA9555R_READ_INTERNALS
+    { MP_ROM_QSTR(MP_QSTR_read_input), &tca_port_read_input_state_obj },
+    { MP_ROM_QSTR(MP_QSTR_read_output), &tca_port_read_output_state_obj },
+    { MP_ROM_QSTR(MP_QSTR_read_config), &tca_port_read_config_state_obj },
+    { MP_ROM_QSTR(MP_QSTR_read_polarity), &tca_port_read_polarity_state_obj },
+    #if TCA9555R_LOCAL_MEMORY
+    { MP_ROM_QSTR(MP_QSTR_stored_output), &tca_port_stored_output_state_obj },
+    { MP_ROM_QSTR(MP_QSTR_stored_config), &tca_port_stored_config_state_obj },
+    { MP_ROM_QSTR(MP_QSTR_stored_polarity), &tca_port_stored_polarity_state_obj },
+    #endif
+    #endif
+    TCA_ENTRIES(0),
+    TCA_ENTRIES(1)
+};
+
+MP_DEFINE_CONST_DICT(tca_module_globals, tca_module_globals_table);
+
+const mp_obj_module_t tca_module = {
+    .base = { &mp_type_module },
+    .globals = (mp_obj_dict_t *)&tca_module_globals,
+};
+
+MP_REGISTER_MODULE(MP_QSTR_tca, tca_module, CIRCUITPY_TCA9555R);
+*/
+#endif // defined(MICROPY_PY_TCA9555) && defined(MICROPY_HW_PIN_EXT_COUNT)
\ No newline at end of file
diff --git a/drivers/tca9555/tca9555.h b/drivers/tca9555/tca9555.h
new file mode 100644
index 000000000..842140ee7
--- /dev/null
+++ b/drivers/tca9555/tca9555.h
@@ -0,0 +1,113 @@
+/*
+ * This file is part of the MicroPython project, http://micropython.org/
+ *
+ * The MIT License (MIT)
+ *
+ * Copyright (c) 2022 Jeff Epler for Adafruit Industries
+ * Copyright (c) 2016 Scott Shawcroft
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#pragma once
+
+#if MICROPY_PY_TCA9555
+
+#include "py/obj.h"
+
+#define INPUT_PORT0  0x00
+#define INPUT_PORT1  0x01
+#define OUTPUT_PORT0  0x02
+#define OUTPUT_PORT1  0x03
+#define POLARITY_PORT0  0x04
+#define POLARITY_PORT1  0x05
+#define CONFIGURATION_PORT0  0x06
+#define CONFIGURATION_PORT1  0x07
+
+#define TCA9555R_CHIP_COUNT     2
+#define TCA9555R_GPIO_COUNT     16
+#define TCA9555R_VIRTUAL_GPIO_COUNT     (TCA9555R_GPIO_COUNT * TCA9555R_CHIP_COUNT)
+#define TCA9555R_CHIP_ADDRESSES { 0x20, 0x26 }
+#ifndef TCA9555R_LOCAL_MEMORY
+#define TCA9555R_LOCAL_MEMORY (0)
+#endif
+
+#ifndef TCA9555R_READ_INTERNALS
+#define TCA9555R_READ_INTERNALS (0)
+#endif
+
+#define PARAM_ASSERTIONS_ENABLED_TCA9555R (0)
+
+#if TCA9555R_LOCAL_MEMORY
+extern uint8_t tca9555r_output_state[TCA9555R_CHIP_COUNT * 2];
+extern uint8_t tca9555r_config_state[TCA9555R_CHIP_COUNT * 2];
+extern uint8_t tca9555r_polarity_state[TCA9555R_CHIP_COUNT * 2];
+#endif
+extern bool i2c_created;
+
+void configure_i2c();
+
+#define HIGH_BYTE(index) (((index) * 2u) + 1u)
+#define LOW_BYTE(index) (((index) * 2u))
+#define IS_PORT1(gpio) (((gpio) % TCA9555R_GPIO_COUNT) >= 8u)
+#define GPIO_BYTE(gpio) ((gpio) >> 3u)
+#define GPIO_BIT_MASK(gpio) (1u << ((gpio) % 8u))
+#define CHIP_FROM_GPIO(gpio) ((gpio) / TCA9555R_GPIO_COUNT)
+#define ADDRESS_FROM_GPIO(gpio) (tca9555r_addresses[CHIP_FROM_GPIO(gpio)])
+
+bool tca_gpio_get_input(uint tca_gpio);
+bool tca_gpio_get_output(uint tca_gpio);
+bool tca_gpio_get_config(uint tca_gpio);
+bool tca_gpio_get_polarity(uint tca_gpio);
+
+void tca_gpio_set_output(uint tca_gpio, bool value);
+void tca_gpio_set_config(uint tca_gpio, bool output);
+void tca_gpio_set_polarity(uint tca_gpio, bool polarity);
+
+uint16_t tca_get_input_port(uint tca_index);
+uint8_t tca_get_input_port_low(uint tca_index);
+uint8_t tca_get_input_port_high(uint tca_index);
+
+uint16_t tca_get_output_port(uint tca_index);
+uint8_t tca_get_output_port_low(uint tca_index);
+uint8_t tca_get_output_port_high(uint tca_index);
+
+uint16_t tca_get_config_port(uint tca_index);
+uint8_t tca_get_config_port_low(uint tca_index);
+uint8_t tca_get_config_port_high(uint tca_index);
+
+uint16_t tca_get_polarity_port(uint tca_index);
+uint8_t tca_get_polarity_port_low(uint tca_index);
+uint8_t tca_get_polarity_port_high(uint tca_index);
+
+void tca_set_output_port(uint tca_index, uint16_t output_state);
+void tca_set_output_port_low(uint tca_index, uint8_t output_state);
+void tca_set_output_port_high(uint tca_index, uint8_t output_state);
+
+void tca_set_config_port(uint tca_index, uint16_t config_state);
+void tca_set_config_port_low(uint tca_index, uint8_t config_state);
+void tca_set_config_port_high(uint tca_index, uint8_t config_state);
+
+void tca_set_polarity_port(uint tca_index, uint16_t polarity_state);
+void tca_set_polarity_port_low(uint tca_index, uint8_t polarity_state);
+void tca_set_polarity_port_high(uint tca_index, uint8_t polarity_state);
+
+void tca_change_output_mask(uint8_t chip, uint16_t mask, uint16_t state);
+
+#endif
\ No newline at end of file
diff --git a/ports/rp2/machine_pin_tca9555.c b/ports/rp2/machine_pin_tca9555.c
new file mode 100644
index 000000000..a1e58b8fe
--- /dev/null
+++ b/ports/rp2/machine_pin_tca9555.c
@@ -0,0 +1,87 @@
+/*
+ * This file is part of the MicroPython project, http://micropython.org/
+ *
+ * The MIT License (MIT)
+ *
+ * Copyright (c) 2016-2022 Damien P. George
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include "py/runtime.h"
+#include "py/mphal.h"
+
+#if defined(MICROPY_PY_TCA9555) && defined(MICROPY_HW_PIN_EXT_COUNT)
+
+#include "modmachine.h"
+#include "machine_pin.h"
+#include "../../drivers/tca9555/tca9555.h"
+
+void machine_pin_ext_init(void) {
+    // Read the state of each IO expander pin, as some are initialised as outputs
+    const mp_map_t *named_map = &pin_board_pins_locals_dict.map;
+    for (uint i = 0; i < named_map->used; i++) {
+        machine_pin_obj_t *pin = (machine_pin_obj_t *)named_map->table[i].value;
+         if(pin->is_ext) {
+            pin->last_output_value = tca_gpio_get_output(pin->id);
+            pin->is_output = tca_gpio_get_config(pin->id);
+        }
+    }
+}
+
+void machine_pin_ext_set(machine_pin_obj_t *self, bool value) {
+    tca_gpio_set_output(self->id, value);
+    tca_gpio_set_config(self->id, true);  // Set to output (even if we already think it is)
+    self->last_output_value = value;
+    self->is_output = true;
+}
+
+bool machine_pin_ext_get(machine_pin_obj_t *self) {
+    bool value;
+    if (self->is_output) {
+        value = tca_gpio_get_output(self->id);
+    } else {
+        value = tca_gpio_get_input(self->id);
+    }
+    return value;
+}
+
+void machine_pin_ext_config(machine_pin_obj_t *self, int mode, int value) {
+    if (mode == MACHINE_PIN_MODE_IN) {
+        if (value != -1) {
+            // figure if you pass a value to IN it should still remember it (this is what regular GPIO does)
+            tca_gpio_set_output(self->id, value);
+            self->last_output_value = value;
+        }
+        tca_gpio_set_config(self->id, false);  // Set to input (even if we already think it is)
+        self->is_output = false;
+    } else if (mode == MACHINE_PIN_MODE_OUT) {
+        if (value == -1) {
+            value = self->last_output_value;
+        }
+        machine_pin_ext_set(self, value);
+    } else {
+        mp_raise_ValueError("only Pin.OUT and Pin.IN are supported for this pin");
+    }
+}
+
+#endif // defined(MICROPY_PY_TCA9555) && defined(MICROPY_HW_PIN_EXT_COUNT)
